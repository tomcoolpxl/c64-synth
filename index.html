<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>C64 Sequencer - Authentic 40x24</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; height: 100vh; align-items: center; }
        canvas { box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

<script>

/**
 * C64 AUDIO ENGINE
 */
class C64Sequencer {
    constructor(scene, trackDataRef) {
        this.scene = scene;
        this.TRACKS = trackDataRef; 
        this.context = null;
        this.oscs = [];
        this.isPlaying = false;
        this.currentStep = 0;
        this.PAL_DELAY = 160; 
        this.freqTable = [];
        this.timer = null;
        
        // SID Frequencies
        let f_reg = 40;
        for (let i = 0; i < 255; i++) {
            this.freqTable.push(f_reg * 0.06097);
            f_reg = f_reg * 1.0595;
        }
    }

    start() {
        if (this.isPlaying) return;
        
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        // Reuse context if exists, otherwise create new
        if (!this.context) this.context = new AudioContext();
        
        // Noise Buffer
        const bSize = this.context.sampleRate * 2;
        this.noiseBuffer = this.context.createBuffer(1, bSize, this.context.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;

        this.context.resume().then(() => {
            this.setupVoices();
            this.isPlaying = true;
            this.timer = this.scene.time.addEvent({
                delay: this.PAL_DELAY,
                callback: this.playStep,
                callbackScope: this,
                loop: true
            });
        });
    }

    stop() {
        if (!this.isPlaying) return;
        
        // Kill Timer
        if (this.timer) this.timer.remove();
        
        // Kill Voices
        this.oscs.forEach(v => {
            try {
                v.osc.stop();
                v.osc.disconnect();
                if(v.noiseSrc) {
                    v.noiseSrc.stop();
                    v.noiseSrc.disconnect();
                }
            } catch(e) {} // Ignore if already stopped
        });
        this.oscs = [];
        
        this.isPlaying = false;
        this.currentStep = 0;
        
        // Visual Reset
        this.scene.events.emit('stop');
    }

    setupVoices() {
        this.oscs = [];
        this.TRACKS.forEach(track => {
            const gain = this.context.createGain();
            gain.gain.value = 0;
            gain.connect(this.context.destination);
            let osc = this.context.createOscillator();
            let noiseSrc = null, noiseGain = null;

            if (track.mode === 'bass_snare') {
                osc.type = 'sawtooth';
                osc.connect(gain);
                noiseSrc = this.context.createBufferSource();
                noiseSrc.buffer = this.noiseBuffer;
                noiseSrc.loop = true;
                noiseGain = this.context.createGain();
                noiseGain.gain.value = 0;
                noiseSrc.connect(noiseGain);
                noiseGain.connect(gain);
                noiseSrc.start();
            } else if (track.type === 'square') {
                osc.type = 'square';
                const filter = this.context.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3500;
                osc.connect(filter);
                filter.connect(gain);
            } else {
                osc.type = track.type;
                osc.connect(gain);
            }
            osc.start();
            this.oscs.push({ osc, gain, noiseGain, noiseSrc, track });
        });
    }

    playStep() {
        if (this.currentStep >= 32) this.currentStep = 0;
        const now = this.context.currentTime;
        this.oscs.forEach((v) => {
            const char = v.track.text[this.currentStep];
            const screenCode = (char && char.trim()) ? (char.toUpperCase().charCodeAt(0) - 64) : 32;

            if (screenCode < 1 || screenCode > 26) { 
                if (v.track.mode === 'bass_snare') {
                    v.osc.frequency.setValueAtTime(0, now);
                    v.noiseGain.gain.setValueAtTime(0.5, now);
                    v.gain.gain.cancelScheduledValues(now);
                    v.gain.gain.setValueAtTime(0.3, now);
                    v.gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                } else {
                    v.gain.gain.cancelScheduledValues(now);
                    v.gain.gain.setTargetAtTime(0, now, v.track.release * 0.2);
                }
            } else { 
                if (v.track.mode === 'bass_snare') v.noiseGain.gain.setValueAtTime(0, now);
                const idx = screenCode + v.track.mask;
                if (idx < this.freqTable.length) {
                    v.osc.frequency.setValueAtTime(this.freqTable[idx], now);
                    v.gain.gain.cancelScheduledValues(now);
                    v.gain.gain.setValueAtTime(v.gain.gain.value, now);
                    v.gain.gain.linearRampToValueAtTime(v.track.vol, now + v.track.attack);
                }
            }
        });
        this.scene.events.emit('step', this.currentStep);
        this.currentStep++;
    }
}

/**
 * MAIN SCENE
 */
class EditorScene extends Phaser.Scene {
    constructor() {
        super('EditorScene');
        this.PAD = "                                ";
        this.trackData = [
            { text: ("Q   :   :   R   Q   :   :   M O" + this.PAD).slice(0,32), mask: 82, type: 'triangle', vol: 0.35, attack: 0.05, release: 1.5, mode: 'standard', lineNum: 81 },
            { text: ("T VT:RQMO T XVTQ:M YXVTQ:M QRQO" + this.PAD).slice(0,32), mask: 70, type: 'square', vol: 0.2, attack: 0.01, release: 0.1, mode: 'standard', lineNum: 82 },
            { text: ("AM AMA MHT HTH TJV JVJ VFR FRF R" + this.PAD).slice(0,32), mask: 46, type: 'sawtooth', vol: 0.3, attack: 0.02, release: 0.2, mode: 'bass_snare', lineNum: 83 }
        ];
        
        // C64 Layout Constants (40 Col Grid)
        this.startX = 20;
        this.startY = 60;
        this.lineH = 32; // Tighter vertical packing for the "Mode 40" feel
        this.charW = 19.2; // Approx width of 32px Courier
        this.textOffset = 135; // Offset for "8x REM "
        
        this.cursorRow = 0;
        this.cursorCol = 0;
        this.charObjects = [];
    }

    create() {
        // --- C64 STYLE DEFINITION ---
        // One style to rule them all: 32px Bold Courier
        const c64Style = { 
            fontFamily: '"Courier New", Courier, monospace', 
            fontSize: '32px', 
            fontStyle: 'bold',
            color: '#6c5eb5' // Default Light Blue
        };
        const whiteStyle = { ...c64Style, color: '#ffffff' };
        const darkStyle  = { ...c64Style, color: '#50459b' };

        // --- 1. HEADER (Line 80) ---
        this.add.text(this.startX, this.startY, "80 REM", c64Style);
        const gridString = "+---+---+---+---+---+---+---+---";
        for(let c=0; c<32; c++) {
             this.add.text(this.startX + this.textOffset + (c * this.charW), this.startY, gridString[c], darkStyle);
        }

        // --- 2. EDITABLE TRACKS (81-83) ---
        this.trackData.forEach((track, idx) => {
            const y = this.startY + ((idx + 1) * this.lineH);
            this.add.text(this.startX, y, `${track.lineNum} REM`, c64Style);
            
            this.charObjects[idx] = [];
            for(let c=0; c<32; c++) {
                let t = this.add.text(this.startX + this.textOffset + (c * this.charW), y, track.text[c], whiteStyle);
                this.charObjects[idx].push(t);
            }
        });

        // --- 3. FOOTER (84-86) ---
        this.add.text(this.startX, this.startY + (4 * this.lineH), "84 REM", c64Style);
        
        const y85 = this.startY + (5 * this.lineH);
        this.add.text(this.startX, y85, "85 REM", c64Style);
        // Render helper manually to align chars
        const help1 = "  B D   G I K   N P   S U W   Z ";
        for(let c=0; c<32; c++) {
             this.add.text(this.startX + this.textOffset + (c * this.charW), y85, help1[c], darkStyle);
        }

        const y86 = this.startY + (6 * this.lineH);
        this.add.text(this.startX, y86, "86 REM", c64Style);
        const help2 = " A C E F H J L M O Q R T V X Y";
        for(let c=0; c<32; c++) {
             this.add.text(this.startX + this.textOffset + (c * this.charW), y86, help2[c], darkStyle);
        }

        // --- 4. TITLE & INSTRUCTIONS ---
        // Moved to bottom area to fit 40x24 logic
        this.add.text(this.startX, 20, '*** C64 ASM SEQUENCER ***', c64Style);
        
        // Use a slightly smaller font ONLY for instructions if needed, 
        // but user requested SAME style. We will use the same style but maybe split lines if it overflows.
        // 40 chars * 19px = ~760px. "ARROWS: MOVE | A-Z: NOTE | SPACE: DEL" is ~38 chars. It fits!
        this.add.text(this.startX, 600, 'ARROWS:MOVE  A-Z:NOTE  SPACE:DEL', whiteStyle);

        // --- 5. CURSOR & PLAYHEAD ---
        this.cursor = this.add.rectangle(0, 0, this.charW, this.lineH, 0xffffff, 0.5).setOrigin(0,0);
        this.playhead = this.add.rectangle(0, 0, this.charW, this.lineH * 8, 0x6c5eb5, 0.3).setOrigin(0,0);
        this.playhead.setVisible(false); // Hide initially
        this.updateCursorPos();

        // --- 6. OVERLAY ---
        this.createOverlay(c64Style);

        // --- 7. INPUT & EVENTS ---
        this.input.keyboard.on('keydown', this.handleInput, this);
        
        // Global Click Handler (Stop/Start)
        this.input.on('pointerdown', () => {
            if (this.sequencer && this.sequencer.isPlaying) {
                // STOP Logic
                this.sequencer.stop();
                this.playhead.setVisible(false);
                this.createOverlay(c64Style); // Show overlay again
            }
        });

        this.events.on('step', (step) => {
            this.playhead.setVisible(true);
            this.playhead.x = this.startX + this.textOffset + (step * this.charW);
            this.playhead.y = this.startY;
        });
        
        // Initialize Sequencer (don't start yet)
        this.sequencer = new C64Sequencer(this, this.trackData);
    }

    createOverlay(style) {
        if(this.overlay) return; // Prevent duplicates

        this.overlay = this.add.container(0, 0);
        
        // Darken background
        const bg = this.add.rectangle(400, 320, 800, 640, 0x000000, 0.85);
        
        // Authentic C64 Start Screen text
        const t1 = this.add.text(20, 20, "    **** COMMODORE 64 BASIC V2 ****", { ...style, color: '#6c5eb5' }).setOrigin(0, 0.5);
        const t2 = this.add.text(20, 60, " 64K RAM SYSTEM  38911 BASIC BYTES FREE", { ...style, color: '#6c5eb5' }).setOrigin(0, 0.5);
        const t3 = this.add.text(20, 100, "READY.", { ...style, color: '#6c5eb5' }).setOrigin(0, 0.5);
        const blink = this.add.rectangle(26, 140, 20, 30, 0x6c5eb5).setOrigin(0.5); // Blinking cursor block
        
        this.tweens.add({
            targets: blink,
            alpha: 0,
            duration: 500,
            yoyo: true,
            repeat: -1
        });

        const clickTxt = this.add.text(400, 500, "CLICK TO RUN", { ...style, color: '#ffffff' }).setOrigin(0.5);

        this.overlay.add([bg, t1, t2, t3, blink, clickTxt]);
        this.overlay.setInteractive(new Phaser.Geom.Rectangle(0,0,800,640), Phaser.Geom.Rectangle.Contains);
        
        this.overlay.on('pointerdown', (pointer, localX, localY, event) => {
            event.stopPropagation(); // Prevent bubbling to the stop handler
            this.sequencer.start();
            this.overlay.destroy();
            this.overlay = null;
        });
    }

    updateCursorPos() {
        this.cursor.x = this.startX + this.textOffset + (this.cursorCol * this.charW);
        this.cursor.y = this.startY + ((this.cursorRow + 1) * this.lineH);
    }

    handleInput(e) {
        // Only allow editing if NOT playing (optional preference, but cleaner)
        // If you want editing while playing, remove the check.
        // if(this.sequencer.isPlaying) return; 

        if (e.code === 'ArrowUp') this.cursorRow = Math.max(0, this.cursorRow - 1);
        else if (e.code === 'ArrowDown') this.cursorRow = Math.min(2, this.cursorRow + 1);
        else if (e.code === 'ArrowLeft') this.cursorCol = Math.max(0, this.cursorCol - 1);
        else if (e.code === 'ArrowRight') this.cursorCol = Math.min(31, this.cursorCol + 1);

        let char = null;
        if (e.key.length === 1 && e.key.match(/[a-z]/i)) char = e.key.toUpperCase();
        else if (e.code === 'Space' || e.code === 'Backspace' || e.code === 'Delete') char = ' ';

        if (char !== null) {
            const rowTxt = this.trackData[this.cursorRow].text;
            const newTxt = rowTxt.substring(0, this.cursorCol) + char + rowTxt.substring(this.cursorCol + 1);
            this.trackData[this.cursorRow].text = newTxt;
            this.charObjects[this.cursorRow][this.cursorCol].setText(char);
            if (char !== ' ') this.cursorCol = Math.min(31, this.cursorCol + 1);
        }
        this.updateCursorPos();
    }
}

// Config adapted for 40 columns x 32px font approx
const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 640,
    backgroundColor: '#352879',
    parent: document.body,
    scene: [EditorScene]
};

new Phaser.Game(config);

</script>
</body>
</html>