# C64 Assembly Sequencer Port

A high-fidelity JavaScript port of the legendary 249-byte Commodore 64 musical sequencer originally written in 6502 Assembly and BASIC by [Linus Åkesson (lftkryo)](https://linusakesson.net/).

## AI & Development

This mini-project served as a focused test of the **Gemini Pro CLI** to see if an AI agent could successfully translate hardware-level logic from 1980s BASIC and 6502 Assembly into a modern, functional JavaScript application.

The AI managed to decipher the frequency table generation, the screen memory scanning logic, and the "Snare Hack" synthesis trick. A fully working prototype, including the interactive sequencer, was delivered within **45 minutes** with only "gentle coaching" to refine the hardware timings. 

Subsequent development time was spent building the authentic C64 "mini-simulator" interface (the virtual grid, cursor, and interactive BASIC shell) and refactoring the generated code into a clean, modular ES6 codebase.

## Origin & Concept

This project replicates a specific, highly optimized workflow where the C64's built-in BASIC environment acts as the sequencer's User Interface. Instead of building a complex GUI, the assembly program reads note data directly from the characters typed onto the screen.

### The Original BASIC Loader
The entire sequencer is generated by this BASIC program. It reads machine code from DATA statements, writes it to memory, generates the frequency table, and sets up the screen:

```basic
10 READ V: IF V>=0 THEN POKE A,V: A=A+1: GOTO 10
20 IF V<-1 THEN A=-V*256: GOTO 10
30 F=40: FOR I=0 TO 116
40 POKE 194*256+I, F AND 255
50 POKE 195*256+I, F/256
60 F=F*1.0595: NEXT
80 REM +---+---+---+---+---+---+---+---
81 REM Q   :   :   R   Q   :   :   M O
82 REM T VT:RQMO T XVTQ:M YXVTQ:M QRQO
83 REM AM AMA MHT HTH TJV JVJ VFR FRF R
84 REM
85 REM   B D   G I K   N P   S U W   Z
86 REM  A C E F H J L M O Q R T V X Y
90 SYS 192*256
98 PRINT CHR$(147)
99 LIST 80-89
100 DATA -212
110 DATA 0,0,0,0,0,0,239
120 DATA 0,0,0,4,0,0,224
130 DATA 0,0,0,0,0,128,232
140 DATA 0,0,0,15
200 DATA -192
210 DATA 169,127,141,13,220
220 DATA 169,0,141,20,3
230 DATA 169,193,141,21,3
240 DATA 169,1,141,26,208,141,18,208
290 DATA 96
300 DATA -193
310 DATA 169,1,141,32,208,141,25,208
320 DATA 173,162,0,74,74,74,168
324 DATA 169,14,153,86,216,141,118,216
325 DATA 169,1,153,87,216
330 DATA 185,127,4,72
331 DATA 185,167,4,72
332 DATA 185,207,4
340 DATA 162,14,32,0,196
341 DATA 104,162,7,32,0,196
342 DATA 104,162,0,32,0,196
390 DATA 169,14,141,32,208,76,49,234
400 DATA -196
405 DATA 201,32,144,3,76,0,197
410 DATA 125,0,198,168
430 DATA 185,0,194,157,0,212
440 DATA 185,0,195,157,1,212
450 DATA 189,1,198,157,4,212
490 DATA 96
500 DATA -197
550 DATA 189,2,198,157,4,212
560 DATA 16,3,157,1,212
590 DATA 96
600 DATA -198
610 DATA 82,17,16,0,0,0,0
620 DATA 70,65,64,0,0,0,0
630 DATA 46,33,128,0,0,0,0
999 DATA -1
```

## The "Clever" Assembly Tricks

This port emulates the specific hardware-level logic used in that 249-byte program:

### 1. Screen RAM as Sequencer Data
The C64 stores its screen characters at memory address `$0400` (1024). The assembly code reads offsets `+127`, `+167`, and `+207`. In 40-column mode, these correspond exactly to three specific lines of text on the screen. By typing letters (A-Z) on these lines, the user is "writing" to the sequencer's pattern memory in real-time.

### 2. The Bass & Snare Hybrid (Voice 3)
One of the most brilliant hacks in the original code is how it handles the baseline and percussion on a single SID voice:
*   **Bass Tone:** When the sequencer reads a letter (Note On), it plays a low **Sawtooth** wave.
*   **The Snare Trick:** When it reads a Space character (Note Off), instead of just silencing the voice, it switches the waveform to **Noise** and turns the Gate bit off. The "Release" phase of the envelope then plays a fading burst of white noise, creating a synthesized **Snare Drum** effect automatically.

### 3. Timing via the Jiffy Clock
The sequencer doesn't use a dedicated timer. It reads the C64 system interrupt clock (the "Jiffy Clock" at `$A2`), bit-shifts it right by 3 places (`LSR`) to create a divide-by-8 tempo, and uses that to step through the 32 notes of the pattern.

## Port Features

*   **Interactive Shell:** Boots directly into a "READY." prompt.
*   **True-to-Life Logic:** Implements the exact pitch-masking math from the original ASM (`ADC` values 82, 70, 46).
*   **High-Res Pixel Font:** Uses the "Sixtyfour" variable font, rendered at 64px and downscaled to 0.25 to ensure the "square" pixel structure is perfectly preserved without browser blurring.
*   **PAL Accuracy:** Tuned to the 985,248Hz PAL clock for the authentic 6581 SID sound.

## Controls

*   **Intro:** Type `RUN` (provided) and press **ENTER**.
*   **Sequencer:**
    *   **Arrow Keys:** Navigate the screen.
    *   **A-Z:** Write notes (Letters determine pitch via the ASM mask).
    *   **Space:** Delete note (Triggers Snare on Voice 3).
    *   **Click:** Return to the BASIC prompt.

## Credits

*   **Original Concept & ASM:** [Linus Åkesson (lftkryo)](https://linusakesson.net/)
*   **Reference Video:** [Making 8-bit Music From Scratch](https://www.youtube.com/watch?v=ly5BhGOt2vE)